<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Current Song</title>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.1/dist/chart.min.js"></script>

</head>
<body class="bg-gray-900 text-white font-sans">

<!-- Adicione isto dentro da tag <body>, preferencialmente no início -->
<div class="fixed top-0 right-0 z-50 p-4">
    <a href="/spotify/redirect"
       class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-300">
        Sincronizar Novamente com o Relógio
    </a>
</div>

    <div id="song-info" class="text-center mt-20">
        <h3 id="song-title" class="text-3xl mb-4">{{ song.title }} - {{ song.artist }}</h3>

        <!-- Vinyl Container with continuous spinning animation -->
        <div class="relative inline-block mb-10 animate-spin-fast">
            <div class="w-64 h-64 rounded-full bg-gradient-to-r from-gray-800 via-gray-700 to-gray-600 relative mx-auto">
                <!-- Album Cover in the center (spinning with the vinyl) -->
                <img id="album-cover" src="{{ song.album_cover }}" alt="Album Cover" class="w-44 h-44 rounded-full absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 border-4 border-white object-cover scale-105">
            </div>
        </div>



        <!-- Song Info 
        <div class="text-xl mb-6">
            <p>Duration: {{ song.duration }} seconds</p>
            <p>Time: {{ song.time }} seconds</p>
        </div>-->

        <!-- Progress Bar -->
        <div id="progress-container" class="w-64 mx-auto mt-4">
            <input
            id="progress-bar"
            type="range"
            min="0"
            max="{{ song.duration }}"
            class="w-full h-2 bg-gray-300 rounded-lg appearance-none focus:outline-none focus:ring-2 focus:ring-blue-500"/>
            
            <div class="flex justify-between text-sm text-gray-600 mt-1">
                <span id="current-time">0:00</span>
                <span id="total-time">{{ song.duration|date:"i:s" }}</span>
            </div>
        </div>
        

        <!-- Controls -->
        <div class="flex justify-center space-x-4">
            <button id="previous-btn" class="bg-blue-500 hover:bg-blue-600 text-white px-6 py-3 rounded-lg text-lg">Previous</button>
            <button id="play-pause-btn" class="bg-green-500 hover:bg-green-600 text-white px-6 py-3 rounded-lg text-lg" data-action="resume">Play</button>
            <button id="stop-btn" class="bg-red-500 hover:bg-red-600 text-white px-6 py-3 rounded-lg text-lg" data-action="stop">Stop</button>
            <button id="skip-btn" class="bg-yellow-500 hover:bg-yellow-600 text-white px-6 py-3 rounded-lg text-lg">Skip</button>
        </div>
    </div>


        </div>

    </div>

    <!-- Heart Rate Section -->
    <div id="heart-rate-section" class="mt-8 p-6 bg-gray-800 rounded-xl shadow-lg">
        <h3 class="text-2xl font-bold mb-4 text-center">Heart Rate Monitor</h3>

        <!-- Heart Rate Value with Animation -->
        <div class="flex justify-center items-center space-x-4">
            <div class="relative">
                <!-- Heart Icon Pulse -->
                <div id="heart-icon" class="text-red-500 text-8xl animate-pulse">❤️</div>
                <!-- BPM Value -->
                <div id="heart-rate-value" class="absolute inset-0 flex items-center justify-center text-white font-bold text-xl">
                    -- BPM
                </div>
            </div>
        </div>


    <!-- Volume vs. Heart Rate Correlation -->
    <div class="mt-6 text-center">
        <p id="volume-heart-correlation" class="text-gray-300">Volume: --%</p>
        <p id="genre-effect" class="text-sm text-gray-400">Género: -- | Efeito: --</p>
    </div>
</div>

<!-- Visual Graph (Simple Bar for now) -->
<!-- Contêiner do gráfico com tamanho fixo -->
<div class="w-full max-w-3xl mx-auto bg-gray-800 rounded-lg p-4 mt-6">
    <canvas id="heartVolumeChart" height="300"></canvas>
</div>

<!-- Novos gráficos de análise -->
<div class="w-full max-w-6xl mx-auto mt-12 space-y-12">
    <!-- Gráfico de Artistas -->
    <div class="bg-gray-800 p-6 rounded-xl">
        <div class="flex justify-between items-center mb-6">
            <h3 class="text-2xl font-bold">Ritmo Cardíaco por Artista</h3>
            <select id="artist-sort" class="bg-gray-700 text-white px-4 py-2 rounded-lg">
                <option value="desc">Maiores Médias</option>
                <option value="asc">Menores Médias</option>
            </select>
        </div>
        <canvas id="artistChart" height="400"></canvas>
    </div>

    <!-- Gráfico de Generos -->
    <div class="bg-gray-800 p-6 rounded-xl">
        <div class="flex justify-between items-center mb-6">
            <h3 class="text-2xl font-bold">Ritmo Cardíaco por Gênero</h3>
            <select id="genre-sort" class="bg-gray-700 text-white px-4 py-2 rounded-lg">
                <option value="desc">Maiores Médias</option>
                <option value="asc">Menores Médias</option>
            </select>
        </div>
        <canvas id="genreChart" height="400"></canvas>
    </div>
</div>



</body>
    <script>
        $(document).ready(function() {

        // Elementos da página
        const progressBar = document.getElementById("progress-bar");
        const currentTimeLabel = document.getElementById("current-time");
        const totalTimeLabel = document.getElementById("total-time");
        const songTitleElement = document.getElementById("song-title"); // <h3 id="song-title">
        const albumCover = document.getElementById("album-cover");
        const heartRateValueElement = $("#heart-rate-value");
        const volumeCorrelationElement = $("#volume-heart-correlation");
        const genreEffectElement = $("#genre-effect");

        // A session key é passada pelo Django via template
        const userKey = "{{ user_key }}";

        // Função para formatar milissegundos para mm:ss
        function formatTime(ms) {
            const minutes = Math.floor(ms / 60000);
            const seconds = Math.floor((ms % 60000) / 1000).toString().padStart(2, '0');
            return `${minutes}:${seconds}`;
        }


        // Adicionar um canvas para o gráfico no HTML
        // Configuração inicial do gráfico
        let heartRateData = [];
        let volumeData = [];
        let timeLabels = [];
        const MAX_DATA_POINTS = 30; // Mantém apenas os últimos 30 pontos

        // Inicializa o gráfico
        const chartCtx = document.getElementById('heartVolumeChart').getContext('2d');
        const heartVolumeChart = new Chart(chartCtx, {
            type: 'line',
            data: {
                labels: timeLabels,
                datasets: [
                    {
                        label: 'Heart Rate (BPM)',
                        data: heartRateData,
                        borderColor: '#ef4444', // Vermelho
                        backgroundColor: 'rgba(239, 68, 68, 0.1)',
                        borderWidth: 2,
                        tension: 0.3,
                        yAxisID: 'y'
                    },
                    {
                        label: 'Volume (%)',
                        data: volumeData,
                        borderColor: '#3b82f6', // Azul
                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                        borderWidth: 2,
                        tension: 0.3,
                        yAxisID: 'y1'
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: {
                    duration: 500 // Suaviza as transições
                },
                plugins: {
                    legend: {
                        labels: {
                            color: '#e5e7eb', // Cor branca para a legenda
                            font: {
                                size: 12
                            }
                        }
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false
                    }
                },
                scales: {
                    x: {
                        grid: {
                            color: 'rgba(229, 231, 235, 0.1)'
                        },
                        ticks: {
                            color: '#9ca3af'
                        }
                    },
                    y: {
                        type: 'linear',
                        display: true,
                        position: 'left',
                        min: 40, // Valor mínimo razoável para BPM
                        max: 120, // Valor máximo inicial para BPM
                        grid: {
                            color: 'rgba(239, 68, 68, 0.1)' // Grid sutil para BPM
                        },
                        ticks: {
                            color: '#ef4444' // Cor do texto do eixo
                        },
                        title: {
                            display: true,
                            text: 'Heart Rate (BPM)',
                            color: '#ef4444'
                        }
                    },
                    y1: {
                        type: 'linear',
                        display: true,
                        position: 'right',
                        min: 0,
                        max: 100, // Volume vai de 0% a 100%
                        grid: {
                            drawOnChartArea: false // Não mostra grid para o eixo direito
                        },
                        ticks: {
                            color: '#3b82f6' // Cor do texto do eixo
                        },
                        title: {
                            display: true,
                            text: 'Volume (%)',
                            color: '#3b82f6'
                        }
                    }
                }
            }
        });

        // Função para atualizar o gráfico
        function updateChart(heartRate, volume) {
            const now = new Date();
            const timeString = `${now.getHours()}:${now.getMinutes()}:${now.getSeconds()}`;

            // Adiciona novos dados
            heartRateData.push(heartRate);
            volumeData.push(volume);
            timeLabels.push(timeString);

            // Remove dados antigos se exceder o máximo
            if (heartRateData.length > MAX_DATA_POINTS) {
                heartRateData.shift();
                volumeData.shift();
                timeLabels.shift();
            }

            // Calcula o valor máximo entre ritmo cardíaco e volume (com margem de 15%)
            const maxHeartRate = Math.max(...heartRateData);
            const maxVolume = Math.max(...volumeData);
            const globalMax = Math.max(maxHeartRate, maxVolume) * 1.15; // 15% de margem

            // Atualiza os limites dos eixos Y
            heartVolumeChart.options.scales.y.max = globalMax; // Eixo esquerdo (BPM)
            heartVolumeChart.options.scales.y1.max = globalMax; // Eixo direito (Volume)

            // Mantém os mínimos fixos
            heartVolumeChart.options.scales.y.min = 40; // Mínimo para BPM
            heartVolumeChart.options.scales.y1.min = 0; // Mínimo para Volume

            // Atualiza o gráfico
            heartVolumeChart.data.labels = timeLabels;
            heartVolumeChart.data.datasets[0].data = heartRateData;
            heartVolumeChart.data.datasets[1].data = volumeData;
            heartVolumeChart.update();
        }



        // Gráficos de análise
        let artistChart, genreChart;

        // Cores personalizadas
        const chartColors = {
            artist: '#ef4444',   // Vermelho
            genre: '#3b82f6'     // Azul
        };

        // Configuração comum dos gráficos
        const chartConfig = {
            type: 'bar',
            options: {
                indexAxis: 'y',
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            label: (context) => `${context.parsed.x} BPM (${context.dataset.counts[context.dataIndex]} plays)`
                        }
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Ritmo Cardíaco Médio (BPM)'
                        }
                    },
                    y: {
                        ticks: {
                            autoSkip: false
                        }
                    }
                }
            }
        };

        // Função para processar dados
        function processData(rawData, minCount) {
            return Object.values(rawData)
                .filter(item => item.contagem > minCount)
                .map(item => ({
                    label: item.artista || Object.keys(item)[0], // Ajuste para gêneros
                    value: item.media_ritmo_cardiaco,
                    count: item.contagem
                }));
        }

        // Processamento específico para dados de artistas
        function processArtistData(rawData, minCount) {
            return Object.entries(rawData)  // Converte o objeto em array de [key, value]
                .filter(([id, stats]) => stats.contagem > minCount)
                .map(([id, stats]) => ({
                    label: stats.artista,
                    value: stats.media_ritmo_cardiaco,
                    count: stats.contagem
                }));
        }

        // Processamento específico para dados de gêneros
        function processGenreData(rawData, minCount) {
            return Object.entries(rawData)  // Converte o objeto em array de [gênero, stats]
                .filter(([genre, stats]) => stats.contagem > minCount)
                .map(([genre, stats]) => ({
                    label: genre,
                    value: stats.media_ritmo_cardiaco,
                    count: stats.contagem
                }));
        }

        // Função para atualizar gráficos
        async function updateAnalysisCharts() {
            try {
                const [artistRes, genreRes] = await Promise.all([
                    fetch(`/spotify/api/artist-stats/?min_count=40&sort=${document.getElementById('artist-sort').value}`),
                    fetch(`/spotify/api/genre-stats/?min_count=40&sort=${document.getElementById('genre-sort').value}`)
                ]);

                const artistData = await artistRes.json();
                const genreData = await genreRes.json();

                // Processar dados com ordenação
                const processedArtistData = processArtistData(artistData, 40);
                const processedGenreData = processGenreData(genreData, 40);

                updateChartData(artistChart, processedArtistData, chartColors.artist);
                updateChartData(genreChart, processedGenreData, chartColors.genre);

            } catch (error) {
                console.error('Error updating analysis charts:', error);
            }
        }

       function updateChartData(chart, data, color) {
            const sortOrder = chart === artistChart
                ? document.getElementById('artist-sort').value
                : document.getElementById('genre-sort').value;

            const sortedData = data.sort((a, b) =>
                sortOrder === 'desc' ? b.value - a.value : a.value - b.value
            ).slice(0, 10);

            chart.data.labels = sortedData.map(d => d.label);
            chart.data.datasets[0].data = sortedData.map(d => d.value);
            chart.data.datasets[0].counts = sortedData.map(d => d.count);
            chart.data.datasets[0].backgroundColor = color;

            if (sortOrder === 'asc') {
                chart.options.scales.x.title.text = 'Ritmo Cardíaco Médio (BPM) - Menores';
            } else {
                chart.options.scales.x.title.text = 'Ritmo Cardíaco Médio (BPM) - Maiores';
            }
            chart.update();
                    }

        // Inicialização dos gráficos
        function initializeAnalysisCharts() {
            console.log("A INICIALIZAR GRÁFICOS")
            // Gráfico de Artistas
            artistChart = new Chart(document.getElementById('artistChart'), {
                ...chartConfig,
                data: {
                    labels: [],
                    datasets: [{
                        data: [],
                        counts: [],
                        backgroundColor: chartColors.artist
                    }]
                }
            });

            // Gráfico de GEneros
            genreChart = new Chart(document.getElementById('genreChart'), {
                ...chartConfig,
                data: {
                    labels: [],
                    datasets: [{
                        data: [],
                        counts: [],
                        backgroundColor: chartColors.genre
                    }]
                }
            });

            // Event listeners
            document.getElementById('artist-sort').addEventListener('change', updateAnalysisCharts);
            document.getElementById('genre-sort').addEventListener('change', updateAnalysisCharts);

            // Carregar dados iniciais
            updateAnalysisCharts();
            setInterval(updateAnalysisCharts, 30000);
        }


        // Função para atualizar a UI com os dados sincronizados
        function fetchSyncedData() {
            fetch(`/spotify/api/synced-data/?session_key=${userKey}`, {
                method: "GET",
                headers: { "X-Requested-With": "XMLHttpRequest" },
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    // Atualiza informações da música e ritmo cardíaco

                    // Atualiza o título da música e artista se mudou
                    if (data.musica && songTitleElement) {
                        songTitleElement.textContent = `${data.musica} - ${data.artista}`;
                    }

                    // Atualiza a imagem do álbum
                    if (data.album_cover && albumCover) {
                        albumCover.src = data.album_cover;
                    }

                    // Atualiza a progress bar se os dados de tempo estiverem disponíveis
                    if (data.duration && typeof data.time !== "undefined") {
                        progressBar.max = data.duration;
                        progressBar.value = data.time;
                        currentTimeLabel.textContent = formatTime(data.time);
                        totalTimeLabel.textContent = formatTime(data.duration);
                    }

                    // Atualiza o valor do heart rate
                    if (data.ritmo_cardiaco) {
                        heartRateValueElement.text(`${data.ritmo_cardiaco} BPM`);
                        // Ajusta a velocidade da animação do coração (pulse) com base no BPM
                        const pulseSpeed = Math.max(500, 2000 - (data.ritmo_cardiaco * 10));
                        $("#heart-icon").css("animation-duration", `${pulseSpeed}ms`);
                    }

                    // Atualiza a correlação de volume/decibéis, se esses dados estiverem presentes
                    if (data.volume) {
                        volumeCorrelationElement.text(`Volume: ${data.volume || "--"}% | Decibéis: ${data.decibeis_musica} dB`);
                    }

                    if (data.ritmo_cardiaco && data.volume) {
                        updateChart(data.ritmo_cardiaco, data.volume);
                    }

                    // Atualiza o gênero e efeito (exemplo)
                    if (data.genero) {
                        const genStr = Array.isArray(data.genero) && data.genero.length > 0 ? data.genero.join(", ") : "--";
                        // Determina o efeito com base no ritmo cardíaco
                        let efeito;
                        if (data.ritmo_cardiaco > 80) {
                            efeito = "Estimulante";
                        } else if (data.ritmo_cardiaco >= 65 && data.ritmo_cardiaco <= 79) {
                            efeito = "Normal";
                        } else {
                            efeito = "Calmante";
                        }

                        // Atualiza o texto do elemento
                        genreEffectElement.text(`Género: ${genStr} | Efeito: ${efeito}`);
                    }
                })
                .catch(error => {
                    console.error("Erro ao buscar dados sincronizados:", error);
                });
        }

        // Atualiza a progress bar e demais dados a cada 10 segundos
        setInterval(fetchSyncedData, 2000);


        // Exemplo de integração com controle (mantém os botões inalterados):

        // Skip Button
        $("#skip-btn").click(function() {
                var key = "{{ user_key }}";  // Pass the key value from the template

                $.ajax({
                    url: "/spotify/controls/",  // URL for skip action
                    type: "POST",
                    data: {
                        key: key,
                        action: "skip",  // Add action for skipping to next song
                    },
                    success: function(response) {
                        console.log("Skipped to next song:", response);
                        // Optionally update UI to reflect the new song
                    },
                    error: function(response) {
                        console.error("Skip action failed:", response);
                    }
                });
            });


        // Previous Button
        $("#previous-btn").click(function() {
            $.ajax({
                url: "/spotify/controls/",
                method: "POST",
                contentType: "application/json",
                data: JSON.stringify({
                    key: userKey,
                    action: "previous"
                }),
                dataType: "json",
                success: function(response) {
                    console.log("Went to previous song:", response);
                },
                error: function(jqXHR, textStatus, errorThrown) {
                    console.error("Previous action failed:", textStatus, errorThrown, jqXHR.responseText);
                }
            });
        });

        // Play/Pause Button
        $("#play-pause-btn").click(function() {
            var action = $(this).data("action");
            $.ajax({
                url: "/spotify/controls/",
                method: "POST",
                contentType: "application/json",
                data: JSON.stringify({
                    key: userKey,
                    action: action
                }),
                dataType: "json",
                success: function(response) {
                    console.log("Action successful:", response);
                    if (action === "resume") {
                        $("#play-pause-btn").data("action", "stop").text("Pause");
                    } else {
                        $("#play-pause-btn").data("action", "resume").text("Play");
                    }
                },
                error: function(jqXHR, textStatus, errorThrown) {
                    console.error("Action failed:", textStatus, errorThrown, jqXHR.responseText);
                }
            });
        });

        // Stop Button
        $("#stop-btn").click(function() {
            $.ajax({
                url: "/spotify/controls/",
                method: "POST",
                contentType: "application/json",
                data: JSON.stringify({
                    key: userKey,
                    action: "stop"
                }),
                dataType: "json",
                success: function(response) {
                    console.log("Action successful:", response);
                    $("#stop-btn").prop("disabled", true);
                },
                error: function(jqXHR, textStatus, errorThrown) {
                    console.error("Action failed:", textStatus, errorThrown, jqXHR.responseText);
                }
            });
        });


        initializeAnalysisCharts();

        }

            );
    </script>

    <style>
        /* Tailwind Custom continuous animation for fast spinning */
        @keyframes spin-fast {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }

        /* Apply the animation */
        .animate-spin-fast {
            animation: spin-fast 7s linear infinite; /* time to do a whole spin */
        }

        /* Heart Pulse Animation */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }

        .animate-pulse {
            animation: pulse 1.5s infinite;
        }

        /* Chart Container Styling

        #heartVolumeChart {
            background-color: rgba(55, 65, 81, 0.5); *//* bg-gray-700 with opacity
            border-radius: 0%;
            padding: 8px;
        }*/

        #heartVolumeChart {
            width: 100% !important;
            height: 300px !important;
        }

        .chartjs-render-monitor {
            animation: none !important; /* Remove animação inicial */
        }

        #artistChart, #genreChart {
            width: 100% !important;
            height: 400px !important;
        }
    </style>


</html>
